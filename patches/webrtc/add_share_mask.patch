From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xiaoxia Lang <xxlang@grandstream.cn>
Date: Fri, 21 Oct 2022 17:38:35 +0800
Subject: add_share_mask


diff --git a/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.cc b/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.cc
index 4ed9cb2043f0c2d23b3202009094010bbb459fd3..a607f4ffcc69f94390ad094553dae2cad1391eec 100644
--- a/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.cc
+++ b/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.cc
@@ -34,6 +34,7 @@ BlankDetectorDesktopCapturerWrapper::~BlankDetectorDesktopCapturerWrapper() =
 
 void BlankDetectorDesktopCapturerWrapper::Start(
     DesktopCapturer::Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   callback_ = callback;
   capturer_->Start(this);
 }
@@ -48,6 +49,13 @@ void BlankDetectorDesktopCapturerWrapper::CaptureFrame() {
   capturer_->CaptureFrame();
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void BlankDetectorDesktopCapturerWrapper::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  capturer_->SetMaskWindow(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 void BlankDetectorDesktopCapturerWrapper::SetExcludedWindow(WindowId window) {
   capturer_->SetExcludedWindow(window);
 }
diff --git a/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.h b/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.h
index b226ca83dd41c485ace9304db560673283b62593..53637915e36e40775a414a8b3acca2a1d9c7c12a 100644
--- a/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.h
+++ b/modules/desktop_capture/blank_detector_desktop_capturer_wrapper.h
@@ -42,6 +42,7 @@ class BlankDetectorDesktopCapturerWrapper final
   void SetSharedMemoryFactory(
       std::unique_ptr<SharedMemoryFactory> shared_memory_factory) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   void SetExcludedWindow(WindowId window) override;
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
diff --git a/modules/desktop_capture/cropping_window_capturer.cc b/modules/desktop_capture/cropping_window_capturer.cc
index f0f4d6652d52c993ce2ec81781fb20323c60ecf3..b58d55a1833d776b3b5803548411476869f968ef 100644
--- a/modules/desktop_capture/cropping_window_capturer.cc
+++ b/modules/desktop_capture/cropping_window_capturer.cc
@@ -26,6 +26,7 @@ CroppingWindowCapturer::CroppingWindowCapturer(
       callback_(NULL),
       selected_window_(kNullWindowId),
       excluded_window_(kNullWindowId),
+      mask_window_(kNullWindowId), //+by xxlang@2022-10-14 : mask id
       last_capturer_(0), //+by xxlang@2021-09-09
       enable_border_(options.enable_border()), //+by xxlang@2021-09-28
       first_capture_(true), //+by xxlang@2021-09-28
@@ -33,6 +34,7 @@ CroppingWindowCapturer::CroppingWindowCapturer(
 {
   RTC_LOG(LS_WARNING) << "CroppingWindowCapturer " << (enable_border_ ? "with" : "without") << " border";
   options_.set_enable_border(false);
+  RTC_LOG(LS_WARNING) << "CroppingWindowCapturer create window capturer";
   window_capturer_ = DesktopCapturer::CreateRawWindowCapturer(options_);
 }
 
@@ -40,6 +42,7 @@ CroppingWindowCapturer::~CroppingWindowCapturer() {}
 
 void CroppingWindowCapturer::Start(DesktopCapturer::Callback* callback) {
   callback_ = callback;
+  RTC_LOG(LS_WARNING) << "CroppingWindowCapturer start window capturer";
   window_capturer_->Start(callback);
 }
 
@@ -54,11 +57,12 @@ void CroppingWindowCapturer::CaptureFrame() {
     if (first_capture_) {
       first_capture_ = false;
     } else {
-      RTC_LOG(LS_WARNING) << "CroppingWindowCapturer create border for window " << selected_window_;
+      RTC_LOG(LS_WARNING) << "CroppingWindowCapturer create border for window " << selected_window_ << " with mask " << mask_window_;
       window_border_->CreateForWindow(selected_window_);
       if (window_border_->IsCreated()) {
         RTC_LOG(LS_INFO) << "CroppingWindowCapturer exclude border window";
         SetExcludedWindow(window_border_->GetBorderId());
+        window_border_->SetMaskId(mask_window_);
       }
     }
   }
@@ -66,26 +70,36 @@ void CroppingWindowCapturer::CaptureFrame() {
 
   if (ShouldUseScreenCapturer()) {
     if (!screen_capturer_.get()) {
+      RTC_LOG(LS_WARNING) << "CroppingWindowCapturer create screen capturer";
       screen_capturer_ = DesktopCapturer::CreateRawScreenCapturer(options_);
       if (excluded_window_) {
         screen_capturer_->SetExcludedWindow(excluded_window_);
       }
+      RTC_LOG(LS_WARNING) << "CroppingWindowCapturer start screen capturer";
       screen_capturer_->Start(this);
     }
     if (last_capturer_ != 1) {
-      RTC_LOG(LS_WARNING) << "switch to screen capture";
+      RTC_LOG(LS_WARNING) << "CroppingWindowCapturer switch to screen capturer";
       last_capturer_ = 1;
     }
     screen_capturer_->CaptureFrame();
   } else {
     if (last_capturer_ != 2) {
-      RTC_LOG(LS_WARNING) << "switch to window capture";
+      RTC_LOG(LS_WARNING) << "CroppingWindowCapturer switch to window capturer";
       last_capturer_ = 2;
     }
     window_capturer_->CaptureFrame();
   }
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void CroppingWindowCapturer::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  mask_window_ = window;
+  window_capturer_->SetMaskWindow(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 void CroppingWindowCapturer::SetExcludedWindow(WindowId window) {
   RTC_LOG(LS_INFO) << "CroppingWindowCapturer::SetExcludedWindow " << excluded_window_ << " => " << window;
   excluded_window_ = window;
diff --git a/modules/desktop_capture/cropping_window_capturer.h b/modules/desktop_capture/cropping_window_capturer.h
index b08535420dbd6335f3844c8da73d121e9d9b9cd0..f5805f37c7024b56c16655ad9eb96c04949934db 100644
--- a/modules/desktop_capture/cropping_window_capturer.h
+++ b/modules/desktop_capture/cropping_window_capturer.h
@@ -20,6 +20,7 @@
 #include "modules/desktop_capture/desktop_geometry.h"
 #include "modules/desktop_capture/shared_memory.h"
 #include "modules/desktop_capture/window_border.h" //+by xxlang@2021-10-15
+#include "modules/desktop_capture/window_finder_win.h" //+by xxlang@2022-10-11
 #include "rtc_base/system/rtc_export.h"
 
 namespace webrtc {
@@ -40,6 +41,7 @@ class RTC_EXPORT CroppingWindowCapturer : public DesktopCapturer,
   void SetSharedMemoryFactory(
       std::unique_ptr<SharedMemoryFactory> shared_memory_factory) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   void SetExcludedWindow(WindowId window) override;
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
@@ -80,12 +82,14 @@ class RTC_EXPORT CroppingWindowCapturer : public DesktopCapturer,
   std::unique_ptr<DesktopCapturer> screen_capturer_;
   SourceId selected_window_;
   WindowId excluded_window_;
-  int last_capturer_; //+by xxlang@2021-09-09
+  WindowId mask_window_; //+by xxlang@2022-10-14 : mask id
+  int last_capturer_; //+by xxlang@2021-09-09 : 0 - none, 1 - screen, 2 - window.
 
   //+by xxlang@2021-09-28 {
   bool enable_border_;
   bool first_capture_;
   std::unique_ptr<WindowBorder> window_border_;
+  WindowFinderWin window_finder_;
   //+by xxlang@2021-09-28 }
 };
 
diff --git a/modules/desktop_capture/desktop_and_cursor_composer.cc b/modules/desktop_capture/desktop_and_cursor_composer.cc
index f282c1d500ae8f5087d72a041dbe621508949f74..ddedcab4c5ef4748a3312f276939e85c70c53479 100644
--- a/modules/desktop_capture/desktop_and_cursor_composer.cc
+++ b/modules/desktop_capture/desktop_and_cursor_composer.cc
@@ -22,6 +22,7 @@
 #include "modules/desktop_capture/mouse_cursor_monitor.h"
 #include "rtc_base/checks.h"
 #include "rtc_base/constructor_magic.h"
+#include "rtc_base/logging.h"
 
 namespace webrtc {
 
@@ -166,6 +167,7 @@ DesktopAndCursorComposer::CreateWithoutMouseCursorMonitor(
 }
 
 void DesktopAndCursorComposer::Start(DesktopCapturer::Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   callback_ = callback;
   if (mouse_monitor_)
     mouse_monitor_->Init(this, MouseCursorMonitor::SHAPE_AND_POSITION);
@@ -183,6 +185,13 @@ void DesktopAndCursorComposer::CaptureFrame() {
   desktop_capturer_->CaptureFrame();
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void DesktopAndCursorComposer::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  desktop_capturer_->SetMaskWindow(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 void DesktopAndCursorComposer::SetExcludedWindow(WindowId window) {
   desktop_capturer_->SetExcludedWindow(window);
 }
diff --git a/modules/desktop_capture/desktop_and_cursor_composer.h b/modules/desktop_capture/desktop_and_cursor_composer.h
index 8f95721ec295e9496654e81f240cf8543b236456..c04066a73a6e499f963190e1207e35337f451c58 100644
--- a/modules/desktop_capture/desktop_and_cursor_composer.h
+++ b/modules/desktop_capture/desktop_and_cursor_composer.h
@@ -52,6 +52,7 @@ class RTC_EXPORT DesktopAndCursorComposer
   void SetSharedMemoryFactory(
       std::unique_ptr<SharedMemoryFactory> shared_memory_factory) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   void SetExcludedWindow(WindowId window) override;
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
diff --git a/modules/desktop_capture/desktop_capturer.cc b/modules/desktop_capture/desktop_capturer.cc
index d597bf4a8d5098091837c454c7d53d264360662f..2c6831067fea2e95cdb4fe3d66ba157347be69dd 100644
--- a/modules/desktop_capture/desktop_capturer.cc
+++ b/modules/desktop_capture/desktop_capturer.cc
@@ -19,6 +19,7 @@
 #include "modules/desktop_capture/cropping_window_capturer.h"
 #include "modules/desktop_capture/desktop_capture_options.h"
 #include "modules/desktop_capture/desktop_capturer_differ_wrapper.h"
+#include "rtc_base/logging.h"
 
 #if defined(RTC_ENABLE_WIN_WGC)
 #include "modules/desktop_capture/win/wgc_capturer_win.h"
@@ -32,6 +33,8 @@ DesktopCapturer::~DesktopCapturer() = default;
 void DesktopCapturer::SetSharedMemoryFactory(
     std::unique_ptr<SharedMemoryFactory> shared_memory_factory) {}
 
+void DesktopCapturer::SetMaskWindow(WindowId window) {} //+by xxlang@2022-10-14 : mask id
+
 void DesktopCapturer::SetExcludedWindow(WindowId window) {}
 
 bool DesktopCapturer::GetSourceList(SourceList* sources) {
@@ -72,12 +75,14 @@ std::unique_ptr<DesktopCapturer> DesktopCapturer::CreateWindowCapturer(
 
 #if defined(WEBRTC_WIN)
   if (options.allow_cropping_window_capturer()) {
+    RTC_LOG(LS_WARNING) << "cropping_window_capturer is enabled";
     return CroppingWindowCapturer::CreateCapturer(options);
   }
 #endif  // defined(WEBRTC_WIN)
 
   std::unique_ptr<DesktopCapturer> capturer = CreateRawWindowCapturer(options);
   if (capturer && options.detect_updated_region()) {
+    RTC_LOG(LS_WARNING) << "detect_updated_region is enabled";
     capturer.reset(new DesktopCapturerDifferWrapper(std::move(capturer)));
   }
 
@@ -98,6 +103,7 @@ std::unique_ptr<DesktopCapturer> DesktopCapturer::CreateScreenCapturer(
 
   std::unique_ptr<DesktopCapturer> capturer = CreateRawScreenCapturer(options);
   if (capturer && options.detect_updated_region()) {
+    RTC_LOG(LS_WARNING) << "detect_updated_region is enabled";
     capturer.reset(new DesktopCapturerDifferWrapper(std::move(capturer)));
   }
 
diff --git a/modules/desktop_capture/desktop_capturer.h b/modules/desktop_capture/desktop_capturer.h
index b5da3ae3d52466500be0e8c3cdf5af520e386ee4..0be2353a5f554534863e30d0880abfc8ff06fe30 100644
--- a/modules/desktop_capture/desktop_capturer.h
+++ b/modules/desktop_capture/desktop_capturer.h
@@ -96,6 +96,8 @@ class RTC_EXPORT DesktopCapturer {
   // Pending capture requests are canceled when DesktopCapturer is deleted.
   virtual void CaptureFrame() = 0;
 
+  virtual void SetMaskWindow(WindowId window); //+by xxlang@2022-10-14 : mask id
+
   // Sets the window to be excluded from the captured image in the future
   // Capture calls. Used to exclude the screenshare notification window for
   // screen capturing.
diff --git a/modules/desktop_capture/desktop_capturer_differ_wrapper.cc b/modules/desktop_capture/desktop_capturer_differ_wrapper.cc
index 4e80f30520183ae3fcae0ec8e0b60614f8f697c6..54f93a6500525423b6be55d8009e82126aa17531 100644
--- a/modules/desktop_capture/desktop_capturer_differ_wrapper.cc
+++ b/modules/desktop_capture/desktop_capturer_differ_wrapper.cc
@@ -19,6 +19,7 @@
 #include "modules/desktop_capture/desktop_region.h"
 #include "modules/desktop_capture/differ_block.h"
 #include "rtc_base/checks.h"
+#include "rtc_base/logging.h"
 #include "rtc_base/time_utils.h"
 
 namespace webrtc {
@@ -153,6 +154,7 @@ DesktopCapturerDifferWrapper::DesktopCapturerDifferWrapper(
 DesktopCapturerDifferWrapper::~DesktopCapturerDifferWrapper() {}
 
 void DesktopCapturerDifferWrapper::Start(DesktopCapturer::Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   callback_ = callback;
   base_capturer_->Start(this);
 }
@@ -166,6 +168,13 @@ void DesktopCapturerDifferWrapper::CaptureFrame() {
   base_capturer_->CaptureFrame();
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void DesktopCapturerDifferWrapper::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  base_capturer_->SetMaskWindow(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 void DesktopCapturerDifferWrapper::SetExcludedWindow(WindowId window) {
   base_capturer_->SetExcludedWindow(window);
 }
diff --git a/modules/desktop_capture/desktop_capturer_differ_wrapper.h b/modules/desktop_capture/desktop_capturer_differ_wrapper.h
index 1f70cef186c8aa2cfa4f73689ca5eccd58184089..2764ea4b25b8277b5f984ba68d9d27e86a10eb9c 100644
--- a/modules/desktop_capture/desktop_capturer_differ_wrapper.h
+++ b/modules/desktop_capture/desktop_capturer_differ_wrapper.h
@@ -47,6 +47,7 @@ class RTC_EXPORT DesktopCapturerDifferWrapper
   void SetSharedMemoryFactory(
       std::unique_ptr<SharedMemoryFactory> shared_memory_factory) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   void SetExcludedWindow(WindowId window) override;
   bool GetSourceList(SourceList* screens) override;
   bool SelectSource(SourceId id) override;
diff --git a/modules/desktop_capture/desktop_capturer_wrapper.cc b/modules/desktop_capture/desktop_capturer_wrapper.cc
index 4bbdd6c94f1bcf6a36621ba42ff9630a60e152ca..3596a4ff26dbbf25fb5f61ffa55d8b58d52a3d1c 100644
--- a/modules/desktop_capture/desktop_capturer_wrapper.cc
+++ b/modules/desktop_capture/desktop_capturer_wrapper.cc
@@ -13,6 +13,7 @@
 #include <utility>
 
 #include "rtc_base/checks.h"
+#include "rtc_base/logging.h"
 
 namespace webrtc {
 
@@ -25,6 +26,7 @@ DesktopCapturerWrapper::DesktopCapturerWrapper(
 DesktopCapturerWrapper::~DesktopCapturerWrapper() = default;
 
 void DesktopCapturerWrapper::Start(Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   base_capturer_->Start(callback);
 }
 
@@ -37,6 +39,13 @@ void DesktopCapturerWrapper::CaptureFrame() {
   base_capturer_->CaptureFrame();
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void DesktopCapturerWrapper::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  base_capturer_->SetMaskWindow(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 void DesktopCapturerWrapper::SetExcludedWindow(WindowId window) {
   base_capturer_->SetExcludedWindow(window);
 }
diff --git a/modules/desktop_capture/desktop_capturer_wrapper.h b/modules/desktop_capture/desktop_capturer_wrapper.h
index e0f50d79e1dcdd5ef752477e92ec26fe506f6eed..412565503f61e91fd7a30d17d9615b55ccbf6a1c 100644
--- a/modules/desktop_capture/desktop_capturer_wrapper.h
+++ b/modules/desktop_capture/desktop_capturer_wrapper.h
@@ -32,6 +32,7 @@ class DesktopCapturerWrapper : public DesktopCapturer {
   void SetSharedMemoryFactory(
       std::unique_ptr<SharedMemoryFactory> shared_memory_factory) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   void SetExcludedWindow(WindowId window) override;
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
diff --git a/modules/desktop_capture/desktop_frame.cc b/modules/desktop_capture/desktop_frame.cc
index 9e4a899fd26960b553b81beeb265f06e2d3f18f7..793a54dd153ef2e231e24ddbe5485bf570c6ea78 100644
--- a/modules/desktop_capture/desktop_frame.cc
+++ b/modules/desktop_capture/desktop_frame.cc
@@ -41,24 +41,31 @@ DesktopFrame::~DesktopFrame() = default;
 
 void DesktopFrame::CopyPixelsFrom(const uint8_t* src_buffer,
                                   int src_stride,
-                                  const DesktopRect& dest_rect) {
+                                  const DesktopRect& dest_rect,
+                                  bool with_alpha) {
   RTC_CHECK(DesktopRect::MakeSize(size()).ContainsRect(dest_rect));
 
   uint8_t* dest = GetFrameDataAtPos(dest_rect.top_left());
-  libyuv::CopyPlane(src_buffer, src_stride, dest, stride(),
-                    DesktopFrame::kBytesPerPixel * dest_rect.width(),
-                    dest_rect.height());
+  if (with_alpha) //+by xxlang@2022-09-30 : share annotation
+    libyuv::CopyPlaneWithAlpha(src_buffer, src_stride, dest, stride(),
+                      DesktopFrame::kBytesPerPixel * dest_rect.width(),
+                      dest_rect.height());
+  else
+    libyuv::CopyPlane(src_buffer, src_stride, dest, stride(),
+                      DesktopFrame::kBytesPerPixel * dest_rect.width(),
+                      dest_rect.height());
 }
 
 void DesktopFrame::CopyPixelsFrom(const DesktopFrame& src_frame,
                                   const DesktopVector& src_pos,
-                                  const DesktopRect& dest_rect) {
+                                  const DesktopRect& dest_rect,
+                                  bool with_alpha) {
   RTC_CHECK(DesktopRect::MakeSize(src_frame.size())
                 .ContainsRect(
                     DesktopRect::MakeOriginSize(src_pos, dest_rect.size())));
 
   CopyPixelsFrom(src_frame.GetFrameDataAtPos(src_pos), src_frame.stride(),
-                 dest_rect);
+                 dest_rect, with_alpha); //+by xxlang@2022-09-30 : share annotation
 }
 
 bool DesktopFrame::CopyIntersectingPixelsFrom(const DesktopFrame& src_frame,
@@ -98,7 +105,7 @@ bool DesktopFrame::CopyIntersectingPixelsFrom(const DesktopFrame& src_frame,
   int32_t src_pos_y = std::max(0, -src_frame_offset.y());
 
   CopyPixelsFrom(src_frame, DesktopVector(src_pos_x, src_pos_y),
-                 intersection_rect);
+                 intersection_rect, true); //+by xxlang@2022-09-30 : share annotation
   return true;
 }
 
diff --git a/modules/desktop_capture/desktop_frame.h b/modules/desktop_capture/desktop_frame.h
index 4ee3680670c79ca97ca65437b756ad06d9078c51..6602d5b7f8bf4da478bade6f11d7c67ac00d68e2 100644
--- a/modules/desktop_capture/desktop_frame.h
+++ b/modules/desktop_capture/desktop_frame.h
@@ -80,10 +80,12 @@ class RTC_EXPORT DesktopFrame {
   // within bounds of this frame.
   void CopyPixelsFrom(const uint8_t* src_buffer,
                       int src_stride,
-                      const DesktopRect& dest_rect);
+                      const DesktopRect& dest_rect,
+                      bool with_alpha = false); //+by xxlang@2022-09-30 : share annotation
   void CopyPixelsFrom(const DesktopFrame& src_frame,
                       const DesktopVector& src_pos,
-                      const DesktopRect& dest_rect);
+                      const DesktopRect& dest_rect,
+                      bool with_alpha = false); //+by xxlang@2022-09-30 : share annotation
 
   // Copies pixels from another frame, with the copied & overwritten regions
   // representing the intersection between the two frames. Returns true if
diff --git a/modules/desktop_capture/fallback_desktop_capturer_wrapper.cc b/modules/desktop_capture/fallback_desktop_capturer_wrapper.cc
index 9f1bd3c157195ff83000b32733a10deb5610f9b8..f66fa03033dd497ea03e5ac1ce2d5c9c0e14a784 100644
--- a/modules/desktop_capture/fallback_desktop_capturer_wrapper.cc
+++ b/modules/desktop_capture/fallback_desktop_capturer_wrapper.cc
@@ -74,6 +74,7 @@ FallbackDesktopCapturerWrapper::FallbackDesktopCapturerWrapper(
     std::unique_ptr<DesktopCapturer> secondary_capturer)
     : main_capturer_(std::move(main_capturer)),
       secondary_capturer_(std::move(secondary_capturer)),
+      last_capturer_(0), //+by xxlang@2022-10-14
       enable_border_(false), //+by xxlang@2021-11-18
       first_capture_(true), //+by xxlang@2021-11-08
       window_border_(DesktopCapturer::CreateWindowBorder()) //+by xxlang@2021-11-08
@@ -86,6 +87,7 @@ FallbackDesktopCapturerWrapper::~FallbackDesktopCapturerWrapper() = default;
 
 void FallbackDesktopCapturerWrapper::Start(
     DesktopCapturer::Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   callback_ = callback;
   // FallbackDesktopCapturerWrapper catchs the callback of the main capturer,
   // and checks its return value to decide whether the secondary capturer should
@@ -131,12 +133,28 @@ void FallbackDesktopCapturerWrapper::CaptureFrame() {
 
   RTC_DCHECK(callback_);
   if (main_capturer_permanent_error_) {
+    if (last_capturer_ != 2) {
+      RTC_LOG(LS_WARNING) << "FallbackDesktopCapturerWrapper switch to secondary capturer";
+      last_capturer_ = 2;
+    }
     secondary_capturer_->CaptureFrame();
   } else {
+    if (last_capturer_ != 1) {
+      RTC_LOG(LS_WARNING) << "FallbackDesktopCapturerWrapper switch to main capturer";
+      last_capturer_ = 1;
+    }
     main_capturer_->CaptureFrame();
   }
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void FallbackDesktopCapturerWrapper::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  main_capturer_->SetMaskWindow(window);
+  secondary_capturer_->SetMaskWindow(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 void FallbackDesktopCapturerWrapper::SetExcludedWindow(WindowId window) {
   main_capturer_->SetExcludedWindow(window);
   secondary_capturer_->SetExcludedWindow(window);
diff --git a/modules/desktop_capture/fallback_desktop_capturer_wrapper.h b/modules/desktop_capture/fallback_desktop_capturer_wrapper.h
index 63eb051dcaccbd0a1f3a0fd848714e7dc00bc12b..edbf936fee4e569d518190745962dd98b1c34fdb 100644
--- a/modules/desktop_capture/fallback_desktop_capturer_wrapper.h
+++ b/modules/desktop_capture/fallback_desktop_capturer_wrapper.h
@@ -42,6 +42,7 @@ class FallbackDesktopCapturerWrapper final : public DesktopCapturer,
   void SetSharedMemoryFactory(
       std::unique_ptr<SharedMemoryFactory> shared_memory_factory) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   void SetExcludedWindow(WindowId window) override;
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
@@ -62,6 +63,7 @@ class FallbackDesktopCapturerWrapper final : public DesktopCapturer,
   std::unique_ptr<SharedMemoryFactory> shared_memory_factory_;
   bool main_capturer_permanent_error_ = false;
   DesktopCapturer::Callback* callback_ = nullptr;
+  int last_capturer_; //+by xxlang@2022-10-14 : 0 - none, 1 - main, 2 - secondary.
 
   //+by xxlang@2021-11-08 {
   SourceId selected_screen_ = kFullDesktopScreenId;
diff --git a/modules/desktop_capture/linux/window_capturer_x11.cc b/modules/desktop_capture/linux/window_capturer_x11.cc
index 7b947db5af385d2c4c20f03aadf775559be9b5b5..785cce8ab8945f2d3333ef62e540e0f1a9116dcd 100644
--- a/modules/desktop_capture/linux/window_capturer_x11.cc
+++ b/modules/desktop_capture/linux/window_capturer_x11.cc
@@ -70,6 +70,13 @@ WindowCapturerX11::~WindowCapturerX11() {
   x_display_->RemoveEventHandler(ConfigureNotify, this);
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void WindowCapturerX11::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  mask_window_ = window;
+}
+//+by xxlang@2022-10-14 : mask id }
+
 bool WindowCapturerX11::GetSourceList(SourceList* sources) {
   return GetWindowList(&atom_cache_, [this, sources](::Window window) {
     Source w;
@@ -149,6 +156,7 @@ bool WindowCapturerX11::FocusOnSelectedSource() {
 }
 
 void WindowCapturerX11::Start(Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   RTC_DCHECK(!callback_);
   RTC_DCHECK(callback);
 
@@ -192,11 +200,13 @@ void WindowCapturerX11::CaptureFrame() {
   //+by xxlang@2022-01-04 {
   if (enable_border_ && !window_border_->IsCreated()) {
     if (first_capture_) {
-      RTC_LOG(LS_WARNING) << "WindowCapturerX11(" << this << "): Thread=" << rtc::CurrentThreadId() << ", window=" << selected_window_;
       first_capture_ = false;
     } else {
-      RTC_LOG(LS_WARNING) << "WindowCapturerX11 create border for window " << selected_window_;
+      RTC_LOG(LS_WARNING) << "WindowCapturerX11 create border for window " << selected_window_ << " with mask " << mask_window_;
       window_border_->CreateForWindow(selected_window_);
+      if (window_border_->IsCreated()) {
+        window_border_->SetMaskId(mask_window_);
+      }
     }
   }
   //+by xxlang@2022-01-04 }
diff --git a/modules/desktop_capture/linux/window_capturer_x11.h b/modules/desktop_capture/linux/window_capturer_x11.h
index 9d40feb9c66bac98bf5fcb98bc88c854a214b168..b7f95607e90c591dcf93fe3ec8f7a0468991964a 100644
--- a/modules/desktop_capture/linux/window_capturer_x11.h
+++ b/modules/desktop_capture/linux/window_capturer_x11.h
@@ -42,6 +42,7 @@ class WindowCapturerX11 : public DesktopCapturer,
   // DesktopCapturer interface.
   void Start(Callback* callback) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
   bool FocusOnSelectedSource() override;
@@ -63,6 +64,7 @@ class WindowCapturerX11 : public DesktopCapturer,
   bool has_composite_extension_ = false;
 
   ::Window selected_window_ = 0;
+  ::Window mask_window_ = 0; //+by xxlang@2022-10-14 : mask id
   XServerPixelBuffer x_server_pixel_buffer_;
   XAtomCache atom_cache_;
   WindowFinderX11 window_finder_;
diff --git a/modules/desktop_capture/mac/desktop_frame_cgimage.h b/modules/desktop_capture/mac/desktop_frame_cgimage.h
index 8e006665730e1114ea57dc298f18824f3036abc2..bce046fc2b8bdff07e96ef54e3af00d4bfb0cd05 100644
--- a/modules/desktop_capture/mac/desktop_frame_cgimage.h
+++ b/modules/desktop_capture/mac/desktop_frame_cgimage.h
@@ -33,6 +33,9 @@ class DesktopFrameCGImage final : public DesktopFrame {
   static std::unique_ptr<DesktopFrameCGImage> CreateForWindow(
       CGWindowID window_id);
 
+  static std::unique_ptr<DesktopFrameCGImage> CreateForWindowWithMask(
+      CGWindowID window_id, CGWindowID mask_id); //+by xxlang@2022-09-30 : share annotation
+
   ~DesktopFrameCGImage() override;
 
  private:
diff --git a/modules/desktop_capture/mac/desktop_frame_cgimage.mm b/modules/desktop_capture/mac/desktop_frame_cgimage.mm
index fb13fe273880727dd102710dd626a772c4183c51..c88f383a90a24e49f0423a01ad4253589791db8d 100644
--- a/modules/desktop_capture/mac/desktop_frame_cgimage.mm
+++ b/modules/desktop_capture/mac/desktop_frame_cgimage.mm
@@ -41,6 +41,30 @@
   return DesktopFrameCGImage::CreateFromCGImage(cg_image);
 }
 
+//+by xxlang@2022-09-30 : share annotation {
+// static
+std::unique_ptr<DesktopFrameCGImage> DesktopFrameCGImage::CreateForWindowWithMask(CGWindowID window_id, CGWindowID mask_id) {
+  if (window_id == kCGNullWindowID || mask_id == kCGNullWindowID) {
+    return CreateForWindow(window_id);
+  }
+
+  CFMutableArrayRef windowArray = CFArrayCreateMutable(nullptr, 2, nullptr);
+  // Put mask before window.
+  CFArrayAppendValue(windowArray, reinterpret_cast<void*>(mask_id));
+  CFArrayAppendValue(windowArray, reinterpret_cast<void*>(window_id));
+  rtc::ScopedCFTypeRef<CGImageRef> cg_image(
+      CGWindowListCreateImageFromArray(CGRectNull,
+                              windowArray,
+                              kCGWindowImageDefault));
+  CFRelease(windowArray);
+  if (!cg_image) {
+    return nullptr;
+  }
+
+  return DesktopFrameCGImage::CreateFromCGImage(cg_image);
+}
+//+by xxlang@2022-09-30 : share annotation }
+
 // static
 std::unique_ptr<DesktopFrameCGImage> DesktopFrameCGImage::CreateFromCGImage(
     rtc::ScopedCFTypeRef<CGImageRef> cg_image) {
diff --git a/modules/desktop_capture/win/window_capturer_win_gdi.cc b/modules/desktop_capture/win/window_capturer_win_gdi.cc
index 7f1c4ac6e8347d0fbf197c02a69a8a64b6beb73b..91401b1a2354dfb080898a4548f6379ee9411e05 100644
--- a/modules/desktop_capture/win/window_capturer_win_gdi.cc
+++ b/modules/desktop_capture/win/window_capturer_win_gdi.cc
@@ -131,7 +131,7 @@ BOOL CALLBACK OwnedWindowCollector(HWND hwnd, LPARAM param) {
 }
 
 WindowCapturerWinGdi::WindowCapturerWinGdi() {
-  RTC_LOG(LS_INFO) << "DWM composition is " << (window_capture_helper_.IsAeroEnabled() ? "enabled" : "disabled");
+  RTC_LOG(LS_WARNING) << "DWM composition is " << (window_capture_helper_.IsAeroEnabled() ? "enabled" : "disabled");
 }
 WindowCapturerWinGdi::~WindowCapturerWinGdi() {}
 
@@ -193,6 +193,7 @@ bool WindowCapturerWinGdi::IsOccluded(const DesktopVector& pos) {
 }
 
 void WindowCapturerWinGdi::Start(Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   RTC_DCHECK(!callback_);
   RTC_DCHECK(callback);
 
@@ -206,6 +207,13 @@ void WindowCapturerWinGdi::CaptureFrame() {
   callback_->OnCaptureResult(results.result, std::move(results.frame));
 }
 
+//+by xxlang@2022-10-14 : mask id {
+void WindowCapturerWinGdi::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  mask_window_ = reinterpret_cast<HWND>(window);
+}
+//+by xxlang@2022-10-14 : mask id }
+
 WindowCapturerWinGdi::CaptureResults WindowCapturerWinGdi::CaptureFrame(
     bool capture_owned_windows) {
   TRACE_EVENT0("webrtc", "WindowCapturerWinGdi::CaptureFrame");
@@ -396,6 +404,12 @@ WindowCapturerWinGdi::CaptureResults WindowCapturerWinGdi::CaptureFrame(
     if (context.IsSelectedWindowValid()) {
       EnumWindows(OwnedWindowCollector, reinterpret_cast<LPARAM>(&context));
 
+      //+by xxlang@2022-09-30 : share annotation {
+      if (IsWindow(mask_window_)) {
+        owned_windows_.push_back(mask_window_);
+      }
+      //+by xxlang@2022-09-30 : share annotation }
+
       if (!owned_windows_.empty()) {
         if (!owned_window_capturer_) {
           owned_window_capturer_ = std::make_unique<WindowCapturerWinGdi>();
diff --git a/modules/desktop_capture/win/window_capturer_win_gdi.h b/modules/desktop_capture/win/window_capturer_win_gdi.h
index c954c230c991475890b6fcd472bef2d4eeaee682..47e52b11e3c272d0674ec7ad39dc5ba332f7af8e 100644
--- a/modules/desktop_capture/win/window_capturer_win_gdi.h
+++ b/modules/desktop_capture/win/window_capturer_win_gdi.h
@@ -1,76 +1,79 @@
-/*
- *  Copyright (c) 2020 The WebRTC project authors. All Rights Reserved.
- *
- *  Use of this source code is governed by a BSD-style license
- *  that can be found in the LICENSE file in the root of the source
- *  tree. An additional intellectual property rights grant can be found
- *  in the file PATENTS.  All contributing project authors may
- *  be found in the AUTHORS file in the root of the source tree.
- */
-
-#ifndef MODULES_DESKTOP_CAPTURE_WIN_WINDOW_CAPTURER_WIN_GDI_H_
-#define MODULES_DESKTOP_CAPTURE_WIN_WINDOW_CAPTURER_WIN_GDI_H_
-
-#include <map>
-#include <memory>
-#include <vector>
-
-#include "modules/desktop_capture/desktop_capture_options.h"
-#include "modules/desktop_capture/desktop_capturer.h"
-#include "modules/desktop_capture/win/window_capture_utils.h"
-#include "modules/desktop_capture/window_finder_win.h"
-
-namespace webrtc {
-
-class WindowCapturerWinGdi : public DesktopCapturer {
- public:
-  WindowCapturerWinGdi();
-
-  // Disallow copy and assign
-  WindowCapturerWinGdi(const WindowCapturerWinGdi&) = delete;
-  WindowCapturerWinGdi& operator=(const WindowCapturerWinGdi&) = delete;
-
-  ~WindowCapturerWinGdi() override;
-
-  static std::unique_ptr<DesktopCapturer> CreateRawWindowCapturer(
-      const DesktopCaptureOptions& options);
-
-  // DesktopCapturer interface.
-  void Start(Callback* callback) override;
-  void CaptureFrame() override;
-  bool GetSourceList(SourceList* sources) override;
-  bool SelectSource(SourceId id) override;
-  bool FocusOnSelectedSource() override;
-  bool IsOccluded(const DesktopVector& pos) override;
-
- private:
-  struct CaptureResults {
-    Result result;
-    std::unique_ptr<DesktopFrame> frame;
-  };
-
-  CaptureResults CaptureFrame(bool capture_owned_windows);
-
-  Callback* callback_ = nullptr;
-
-  // HWND and HDC for the currently selected window or nullptr if window is not
-  // selected.
-  HWND window_ = nullptr;
-
-  DesktopSize previous_size_;
-
-  WindowCaptureHelperWin window_capture_helper_;
-
-  // This map is used to avoid flickering for the case when SelectWindow() calls
-  // are interleaved with Capture() calls.
-  std::map<HWND, DesktopSize> window_size_map_;
-
-  WindowFinderWin window_finder_;
-
-  std::vector<HWND> owned_windows_;
-  std::unique_ptr<WindowCapturerWinGdi> owned_window_capturer_;
-};
-
-}  // namespace webrtc
-
-#endif  // MODULES_DESKTOP_CAPTURE_WIN_WINDOW_CAPTURER_WIN_GDI_H_
+/*
+ *  Copyright (c) 2020 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef MODULES_DESKTOP_CAPTURE_WIN_WINDOW_CAPTURER_WIN_GDI_H_
+#define MODULES_DESKTOP_CAPTURE_WIN_WINDOW_CAPTURER_WIN_GDI_H_
+
+#include <map>
+#include <memory>
+#include <vector>
+
+#include "modules/desktop_capture/desktop_capture_options.h"
+#include "modules/desktop_capture/desktop_capturer.h"
+#include "modules/desktop_capture/win/window_capture_utils.h"
+#include "modules/desktop_capture/window_finder_win.h"
+
+namespace webrtc {
+
+class WindowCapturerWinGdi : public DesktopCapturer {
+ public:
+  WindowCapturerWinGdi();
+
+  // Disallow copy and assign
+  WindowCapturerWinGdi(const WindowCapturerWinGdi&) = delete;
+  WindowCapturerWinGdi& operator=(const WindowCapturerWinGdi&) = delete;
+
+  ~WindowCapturerWinGdi() override;
+
+  static std::unique_ptr<DesktopCapturer> CreateRawWindowCapturer(
+      const DesktopCaptureOptions& options);
+
+  // DesktopCapturer interface.
+  void Start(Callback* callback) override;
+  void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override;  //+by xxlang@2022-10-14 : mask id
+  bool GetSourceList(SourceList* sources) override;
+  bool SelectSource(SourceId id) override;
+  bool FocusOnSelectedSource() override;
+  bool IsOccluded(const DesktopVector& pos) override;
+
+ private:
+  struct CaptureResults {
+    Result result;
+    std::unique_ptr<DesktopFrame> frame;
+  };
+
+  CaptureResults CaptureFrame(bool capture_owned_windows);
+
+  Callback* callback_ = nullptr;
+
+  // HWND and HDC for the currently selected window or nullptr if window is not
+  // selected.
+  HWND window_ = nullptr;
+
+  HWND mask_window_ = nullptr;  //+by xxlang@2022-10-14 : mask id
+
+  DesktopSize previous_size_;
+
+  WindowCaptureHelperWin window_capture_helper_;
+
+  // This map is used to avoid flickering for the case when SelectWindow() calls
+  // are interleaved with Capture() calls.
+  std::map<HWND, DesktopSize> window_size_map_;
+
+  WindowFinderWin window_finder_;
+
+  std::vector<HWND> owned_windows_;
+  std::unique_ptr<WindowCapturerWinGdi> owned_window_capturer_;
+};
+
+}  // namespace webrtc
+
+#endif  // MODULES_DESKTOP_CAPTURE_WIN_WINDOW_CAPTURER_WIN_GDI_H_
diff --git a/modules/desktop_capture/window_border.h b/modules/desktop_capture/window_border.h
index d81bae8c69354839a6ad97e96b0174b13cc3b84f..5b8fb5595fb0012a9b59678febd7e1b2c8a279a9 100644
--- a/modules/desktop_capture/window_border.h
+++ b/modules/desktop_capture/window_border.h
@@ -27,6 +27,7 @@ class WindowBorder {
   virtual bool IsCreated() = 0;
   virtual void Destroy() = 0;
   virtual WindowId GetBorderId() = 0;
+  virtual void SetMaskId(WindowId mask_id) = 0;
   virtual void OnScreenRectChanged(const DesktopRect &screen_rect) = 0;
 
   static const int kBorderWidth = 4;
diff --git a/modules/desktop_capture/window_border_linux.cc b/modules/desktop_capture/window_border_linux.cc
index c01691cd39b233839b15217cc0d388f980ac79fa..bb09b9cd46c44d7d98d9a273759ad0755dbb0fa1 100644
--- a/modules/desktop_capture/window_border_linux.cc
+++ b/modules/desktop_capture/window_border_linux.cc
@@ -39,6 +39,7 @@ class WindowBorderLinux : public WindowBorder,
   bool IsCreated() override;
   void Destroy() override;
   WindowId GetBorderId() override;
+  void SetMaskId(WindowId mask_id) override;
   void OnScreenRectChanged(const DesktopRect &screen_rect) override;
 
   // SharedXDisplay::XEventHandler interface.
@@ -60,6 +61,7 @@ class WindowBorderLinux : public WindowBorder,
   DesktopRect border_rect_;
   Window border_window_ = 0;
   Window source_window_ = 0;
+  Window mask_window_ = 0;
   DesktopRect frame_extents_;
   cairo_surface_t* surface_ = nullptr;
   cairo_t* cairo_ = nullptr;
@@ -77,11 +79,11 @@ WindowBorderLinux::~WindowBorderLinux() {
 
 void WindowBorderLinux::Init(rtc::scoped_refptr<SharedXDisplay> x_display, int screen_num) {
   if (x_display_) {
-    RTC_LOG(LS_WARNING) << "Init(" << this << "): Thread=" << rtc::CurrentThreadId();
+    RTC_LOG(LS_ERROR) << "Init(" << this << "): Thread=" << rtc::CurrentThreadId();
     return;
   }
 
-  RTC_LOG(LS_INFO) << "Init(" << this << "): Thread=" << rtc::CurrentThreadId();
+  RTC_LOG(LS_WARNING) << "Init(" << this << "): Thread=" << rtc::CurrentThreadId();
   x_display_ = x_display;
   screen_num_ = screen_num;
   root_window_ = RootWindow(display(), screen_num_);
@@ -134,7 +136,7 @@ void WindowBorderLinux::Destroy() {
   }
 
   if (border_window_) {
-    RTC_LOG(LS_INFO) << "Destroy(" << this << "): Thread=" << rtc::CurrentThreadId() << ", border_window=" << border_window_;
+    RTC_LOG(LS_WARNING) << "Destroy(" << this << "): Thread=" << rtc::CurrentThreadId() << ", border_window=" << border_window_;
     XUnmapWindow(display(), border_window_);
     XDestroyWindow(display(), border_window_);
     border_window_ = 0;
@@ -155,7 +157,7 @@ void WindowBorderLinux::Destroy() {
 
 void WindowBorderLinux::Deinit() {
   if (x_display_) {
-    RTC_LOG(LS_INFO) << "Deinit(" << this << "): Thread=" << rtc::CurrentThreadId();
+    RTC_LOG(LS_WARNING) << "Deinit(" << this << "): Thread=" << rtc::CurrentThreadId();
     // ExposureMask
     x_display_->RemoveEventHandler(Expose, this);
 
@@ -171,6 +173,14 @@ WindowId WindowBorderLinux::GetBorderId() {
   return border_window_;
 }
 
+void WindowBorderLinux::SetMaskId(WindowId mask_id) {
+  mask_window_ = static_cast<Window>(mask_id);
+  // move and resize mask window immediately since no timer on Linux.
+  if (mask_window_) {
+    XMoveResizeWindow(display(), mask_window_, border_rect_.left(), border_rect_.top(), border_rect_.width(), border_rect_.height());
+  }
+}
+
 void WindowBorderLinux::OnScreenRectChanged(const DesktopRect &screen_rect) {
   if (!IsCreated()) {
     return;
@@ -197,6 +207,9 @@ void WindowBorderLinux::OnScreenRectChanged(const DesktopRect &screen_rect) {
   border_rect_ = screen_rect;
   if (root_window_ == source_window_) {
     XMoveResizeWindow(display(), border_window_, border_rect_.left(), border_rect_.top(), border_rect_.width(), border_rect_.height());
+    if (mask_window_) {
+      XMoveResizeWindow(display(), mask_window_, border_rect_.left(), border_rect_.top(), border_rect_.width(), border_rect_.height());
+    }
   } else {
     GetFrameExtents(display(), source_window_, &frame_extents_);
     XMoveResizeWindow(display(), border_window_, 0, 0, border_rect_.width(), border_rect_.height());
@@ -303,7 +316,7 @@ bool WindowBorderLinux::Create(const DesktopRect &window_rect, Window source_win
   XMapWindow(display(), border_window_);
   XFlush(display());
 
-  RTC_LOG(LS_INFO) << "Create(" << this << "): Thread=" << rtc::CurrentThreadId()
+  RTC_LOG(LS_WARNING) << "Create(" << this << "): Thread=" << rtc::CurrentThreadId()
                    << ", screen_num=" << screen_num_
                    << ", root_window=" << root_window_
                    << ", source_window=" << source_window_
diff --git a/modules/desktop_capture/window_border_mac.mm b/modules/desktop_capture/window_border_mac.mm
index 3638514fe3d344a7feeb117ef943a5cead35cb67..de59ac6cc0642be02c4bb8b7a85fde58a50c60a5 100644
--- a/modules/desktop_capture/window_border_mac.mm
+++ b/modules/desktop_capture/window_border_mac.mm
@@ -74,6 +74,7 @@ bool IsWindowValid(CGWindowID id) {
   bool IsCreated() override;
   void Destroy() override;
   WindowId GetBorderId() override;
+  void SetMaskId(WindowId mask_id) override;
   void OnScreenRectChanged(const DesktopRect &screen_rect) override;
 
  private:
@@ -81,8 +82,10 @@ bool IsWindowValid(CGWindowID id) {
   void SetTimer();
   void DestroyInternal(bool sync);
 
-  CGWindowID source_id_ = kCGNullWindowID;
   __strong NSWindow *border_window_ = nil;
+  CGWindowID source_id_ = kCGNullWindowID;
+  CGWindowID mask_id_ = kCGNullWindowID;
+  __strong NSWindow *mask_window_ = nil;
   __strong dispatch_source_t window_timer_ = nil;
 
   RTC_DISALLOW_COPY_AND_ASSIGN(WindowBorderMac);
@@ -143,6 +146,22 @@ bool IsWindowValid(CGWindowID id) {
   }
 }
 
+void WindowBorderMac::SetMaskId(WindowId mask_id) {
+  if (!IsWindowValid(mask_id)) {
+    RTC_LOG(LS_ERROR) << "SetMaskId invalid window: mask_id=" << mask_id;
+    return;
+  }
+
+  mask_window_ = [NSApp windowWithWindowNumber: mask_id];
+  if (nil == mask_window_) {
+    RTC_LOG(LS_ERROR) << "SetMaskId invalid window: mask_id=" << mask_id;
+    return;
+  }
+
+  mask_id_ = mask_id;
+  RTC_LOG(LS_WARNING) << "SetMaskId: mask_id=" << mask_id_ << ", mask_window=" << mask_window_;
+}
+
 void WindowBorderMac::OnScreenRectChanged(const DesktopRect &screen_rect) {
   if (!IsCreated()) {
     return;
@@ -166,13 +185,13 @@ bool IsWindowValid(CGWindowID id) {
   RTC_LOG(LS_INFO) << "Create(" << this << "): Thread=" << rtc::CurrentThreadId();
   // check created
   if (IsCreated()) {
-    RTC_LOG(LS_WARNING) << "Create failed: already created";
+    RTC_LOG(LS_ERROR) << "Create failed: already created";
     return false;
   }
 
   // check parameter
   if (window_rect.is_empty()) {
-    RTC_LOG(LS_WARNING) << "Create failed: empty rect";
+    RTC_LOG(LS_ERROR) << "Create failed: empty rect";
     return false;
   }
 
@@ -203,7 +222,7 @@ bool IsWindowValid(CGWindowID id) {
                                   backing:NSBackingStoreBuffered
                                     defer:NO];
   if (nil == border_window_) {
-    RTC_LOG(LS_WARNING) << "Create border window failed";
+    RTC_LOG(LS_ERROR) << "Create border window failed";
     Destroy();
     return false;
   }
@@ -220,7 +239,7 @@ bool IsWindowValid(CGWindowID id) {
   NSInteger border_id = [border_window_ windowNumber];
   NSInteger border_order = [border_window_ orderedIndex];
   NSRect frame_rect =  [border_window_ frame];
-  RTC_LOG(LS_INFO) << "Create border window OK: window=" << border_window_ <<
+  RTC_LOG(LS_WARNING) << "Create border window OK: window=" << border_window_ <<
                       ", id=" << border_id <<
                       ", order=" << border_order <<
                       ", frame=(" << frame_rect.origin.x << ", " << frame_rect.origin.y << ") " << frame_rect.size.width << "x" << frame_rect.size.height;
@@ -228,7 +247,7 @@ bool IsWindowValid(CGWindowID id) {
   BorderView *borderView =
       [[BorderView alloc] initWithFrame:content_rect];
   if (nil == borderView) {
-    RTC_LOG(LS_WARNING) << "Create border view failed";
+    RTC_LOG(LS_ERROR) << "Create border view failed";
     Destroy();
     return false;
   }
@@ -249,20 +268,25 @@ bool IsWindowValid(CGWindowID id) {
   dispatch_source_set_event_handler(window_timer_, ^{
     WindowBorderMac *pThis = (WindowBorderMac *)dispatch_get_context(window_timer_);
     if (!IsWindowValid(source_id_)) {
-      RTC_LOG(LS_WARNING) << "Timer Event Handler(" << pThis << "): source window is invalid";
+      RTC_LOG(LS_ERROR) << "Timer Event Handler(" << pThis << "): source window is invalid";
       return;
     }
 
     if (nil == border_window_) {
-      RTC_LOG(LS_WARNING) << "Timer Event Handler(" << pThis << "): border window is invalid";
+      RTC_LOG(LS_ERROR) << "Timer Event Handler(" << pThis << "): border window is invalid";
       return;
     }
 
+    // hide window.
     if (!IsWindowOnScreen(source_id_)) {
       if (IsWindowOnScreen(GetBorderId())) {
         RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): border show => hide";
         [border_window_ orderOut:nil];
       }
+      if (IsWindowValid(mask_id_) && IsWindowOnScreen(mask_id_)) {
+        RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): mask show => hide";
+        [mask_window_ orderOut:nil];
+      }
       return;
     }
 
@@ -270,27 +294,56 @@ bool IsWindowValid(CGWindowID id) {
       RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): border hide => show";
     }
 
-    NSWindowLevel border_level = [border_window_ level];
+    if (IsWindowValid(mask_id_) && !IsWindowOnScreen(mask_id_)) {
+      RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): mask hide => show";
+    }
+
+    // window level.
     NSWindowLevel source_level = GetWindowLevel(source_id_);
+    NSWindowLevel border_level = [border_window_ level];
     if (border_level != source_level) {
-      RTC_LOG(LS_WARNING) << "Timer Event Handler(" << pThis << "): border level " << border_level << " => " << source_level;
+      RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): border level " << border_level << " => " << source_level;
       [border_window_ setLevel:source_level];
     }
+    if (IsWindowValid(mask_id_)) {
+      NSWindowLevel mask_level = [mask_window_ level];
+      if (mask_level != source_level) {
+        RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): mask level " << mask_level << " => " << source_level;
+        [mask_window_ setLevel:source_level];
+      }
+    }
 
+    // window order : put border above source.
     NSInteger border_order_old = [border_window_ orderedIndex];
     [border_window_ orderWindow:NSWindowAbove relativeTo:source_id_];
     NSInteger border_order_new = [border_window_ orderedIndex];
     if (border_order_old != border_order_new) {
-//      RTC_LOG(LS_INFO) << "Timer Event Handler(" << pThis << "): border order " << border_order_old << " => " << border_order_new;
+     RTC_LOG(LS_VERBOSE) << "Timer Event Handler(" << pThis << "): border order " << border_order_old << " => " << border_order_new;
+    }
+    // window order : put mask above border.
+    if (IsWindowValid(mask_id_)) {
+      NSInteger mask_order_old = [mask_window_ orderedIndex];
+      [mask_window_ orderWindow:NSWindowAbove relativeTo:GetBorderId()];
+      NSInteger mask_order_new = [mask_window_ orderedIndex];
+      if (mask_order_old != mask_order_new) {
+       RTC_LOG(LS_VERBOSE) << "Timer Event Handler(" << pThis << "): mask order " << mask_order_old << " => " << mask_order_new;
+      }
     }
 
-    NSRect border_nsrect =  [border_window_ frame];
+    // move or resize window.
     DesktopRect source_rect = GetWindowBounds(source_id_);
     gfx::Rect source_gfxrect(source_rect.left(), source_rect.top(), source_rect.width(), source_rect.height());
     NSRect source_nsrect = gfx::ScreenRectToNSRect(source_gfxrect);
+    NSRect border_nsrect = [border_window_ frame];
     if (!NSEqualRects(source_nsrect, border_nsrect)) {
       [border_window_ setFrame:source_nsrect display:YES];
     }
+    if (IsWindowValid(mask_id_)) {
+      NSRect mask_nsrect = [mask_window_ frame];
+      if (!NSEqualRects(source_nsrect, mask_nsrect)) {
+        [mask_window_ setFrame:source_nsrect display:YES];
+      }
+    }
   });
 
   dispatch_resume(window_timer_);
@@ -322,8 +375,13 @@ bool IsWindowValid(CGWindowID id) {
     RTC_LOG(LS_INFO) << "Timer cancelled";
   }
 
+  mask_id_ = kCGNullWindowID;
+  if (mask_window_ != nil) {
+    mask_window_ = nil;
+  }
+
   if (border_window_ != nil) {
-    RTC_LOG(LS_INFO) << "Close border: border_window=" << border_window_;
+    RTC_LOG(LS_WARNING) << "Close border: border_window=" << border_window_;
     [border_window_ close];
     border_window_ = nil; // ARC
     RTC_LOG(LS_INFO) << "Border closed";
diff --git a/modules/desktop_capture/window_border_win.cc b/modules/desktop_capture/window_border_win.cc
index 291fd9739f3d9ac0122887da01eb0b77f91af852..a9a4d287be7898f5bec50ba1f310a7b2263a5337 100644
--- a/modules/desktop_capture/window_border_win.cc
+++ b/modules/desktop_capture/window_border_win.cc
@@ -34,9 +34,11 @@ class WindowBorderWin : public WindowBorder {
   bool IsCreated() override;
   void Destroy() override;
   WindowId GetBorderId() override;
+  void SetMaskId(WindowId mask_id) override;
   void OnScreenRectChanged(const DesktopRect &screen_rect) override;
 
   HWND GetSourceWindow();
+  HWND GetMaskWindow();
   bool GetFrameRect(HWND hwnd, DesktopRect *frame_rect, DesktopRect* original_rect);
 
  private:
@@ -49,6 +51,7 @@ class WindowBorderWin : public WindowBorder {
   ATOM window_class_ = 0;
   HWND border_hwnd_ = nullptr;
   HWND source_hwnd_ = nullptr;
+  HWND mask_hwnd_ = nullptr;
   WindowCaptureHelperWin window_capture_helper_;
 
   RTC_DISALLOW_COPY_AND_ASSIGN(WindowBorderWin);
@@ -343,39 +346,77 @@ VOID CALLBACK UpdateWindowTimerProc(HWND border_hwnd, UINT message, UINT idTimer
     return;
   }
 
+  HWND mask_hwnd = pThis->GetMaskWindow();
+
+  // hide window.
   if (!IsWindowValidAndVisible(source_hwnd)) {
-    if (::IsWindowVisible(border_hwnd)) {
-      UINT uFlags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW;
-      char sFlags[256];
-      FlagString(uFlags, sFlags);
+    UINT uFlags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW;
+    char sFlags[256];
+    FlagString(uFlags, sFlags);
+
+    if (border_hwnd && ::IsWindowVisible(border_hwnd)) {
       if (!::SetWindowPos(border_hwnd, NULL, 0, 0, 0, 0, uFlags)) {
         RTC_LOG(LS_ERROR) << "SetWindowPos Failed: error=" << GetLastError() << ", flags=" << sFlags;
       } else {
         RTC_LOG(LS_INFO) << "Timer Proc(" << pThis << "): Thread=" << rtc::CurrentThreadId() << ": border show => hide";
       }
     }
+
+    if (mask_hwnd && ::IsWindowVisible(mask_hwnd)) {
+      if (!::SetWindowPos(mask_hwnd, NULL, 0, 0, 0, 0, uFlags)) {
+        RTC_LOG(LS_ERROR) << "SetWindowPos Failed: error=" << GetLastError() << ", flags=" << sFlags;
+      } else {
+        RTC_LOG(LS_INFO) << "Timer Proc(" << pThis << "): Thread=" << rtc::CurrentThreadId() << ": mask show => hide";
+      }
+    }
+
     return;
   }
 
-  if (!::IsWindowVisible(border_hwnd)) {
-    RTC_LOG(LS_INFO) << "Timer Proc(" << pThis << "): Thread=" << rtc::CurrentThreadId() << ": border hide => show";
+  // window order : put border above source.
+  if (border_hwnd) {
+    if (!::IsWindowVisible(border_hwnd)) {
+      RTC_LOG(LS_INFO) << "Timer Proc(" << pThis << "): Thread=" << rtc::CurrentThreadId() << ": border hide => show";
+    }
+    SetWindowBefore(border_hwnd, source_hwnd);
   }
 
-  SetWindowBefore(border_hwnd, source_hwnd);
-
-  DesktopRect border_rect;
-  if (!GetWindowRect(border_hwnd, &border_rect)) {
-    RTC_LOG(LS_ERROR) << "GetWindowRect Failed: error=" << GetLastError();
-    return;
+  // window order : put mask above border.
+  if (mask_hwnd) {
+    if (!::IsWindowVisible(mask_hwnd)) {
+      RTC_LOG(LS_INFO) << "Timer Proc(" << pThis << "): Thread=" << rtc::CurrentThreadId() << ": mask hide => show";
+    }
+    SetWindowBefore(mask_hwnd, border_hwnd);
   }
 
+  // move or resize window.
   DesktopRect source_rect;
   if (!pThis->GetFrameRect(source_hwnd, &source_rect, nullptr)) {
     return;
   }
 
-  if (!border_rect.equals(source_rect)) { // move or resize
-    UpdateBorderWindow(border_hwnd, source_rect);
+  if (border_hwnd) {
+    DesktopRect border_rect;
+    if (GetWindowRect(border_hwnd, &border_rect)) {
+      if (!border_rect.equals(source_rect)) {
+        UpdateBorderWindow(border_hwnd, source_rect);
+      }
+    } else {
+      RTC_LOG(LS_ERROR) << "GetWindowRect Failed: error=" << GetLastError();
+    }
+  }
+
+  if (mask_hwnd) {
+    DesktopRect mask_rect;
+    if (GetWindowRect(mask_hwnd, &mask_rect)) {
+      if (!mask_rect.equals(source_rect)) {
+        if (!::MoveWindow(mask_hwnd, source_rect.left(), source_rect.top(), source_rect.width(), source_rect.height(), TRUE)) {
+          RTC_LOG(LS_ERROR) << "MoveWindow Failed: error=" << GetLastError();
+        }
+      }
+    } else {
+      RTC_LOG(LS_ERROR) << "GetWindowRect Failed: error=" << GetLastError();
+    }
   }
 }
 
@@ -440,7 +481,7 @@ bool WindowBorderWin::IsCreated() {
 
 void WindowBorderWin::Destroy() {
   if (nullptr != border_hwnd_) {
-    RTC_LOG(LS_INFO) << "Destroy(" << this << "): Thread=" << rtc::CurrentThreadId() << ": border_hwnd=" << border_hwnd_;
+    RTC_LOG(LS_WARNING) << "Destroy(" << this << "): Thread=" << rtc::CurrentThreadId() << ": border_hwnd=" << border_hwnd_;
     ::KillTimer(border_hwnd_, ID_UPDATE_TIMER);
     ::DestroyWindow(border_hwnd_);
     border_hwnd_ = nullptr;
@@ -459,6 +500,10 @@ WindowId WindowBorderWin::GetBorderId() {
   return reinterpret_cast<WindowId>(border_hwnd_);
 }
 
+void WindowBorderWin::SetMaskId(WindowId mask_id) {
+  mask_hwnd_ = reinterpret_cast<HWND>(mask_id);
+}
+
 void WindowBorderWin::OnScreenRectChanged(const DesktopRect &screen_rect) {
   if (!IsCreated()) {
     return;
@@ -488,6 +533,10 @@ HWND WindowBorderWin::GetSourceWindow() {
   return source_hwnd_;
 }
 
+HWND WindowBorderWin::GetMaskWindow() {
+  return mask_hwnd_;
+}
+
 bool WindowBorderWin::GetFrameRect(HWND hwnd, DesktopRect* frame_rect, DesktopRect* original_rect) {
   DesktopRect window_rect;
   if (!GetWindowRect(hwnd, &window_rect)) {
@@ -585,7 +634,7 @@ bool WindowBorderWin::Create(const DesktopRect &window_rect, HWND source_hwnd) {
     return false;
   }
 
-  RTC_LOG(LS_INFO) << "Create(" << this << "): Thread=" << rtc::CurrentThreadId() << ": border_hwnd=" << border_hwnd_ <<
+  RTC_LOG(LS_WARNING) << "Create(" << this << "): Thread=" << rtc::CurrentThreadId() << ": border_hwnd=" << border_hwnd_ <<
                       " (" << window_rect.left() << ", " << window_rect.top() << ") " << window_rect.width() << "x" << window_rect.height();
   ::ShowWindow(border_hwnd_, SW_SHOWNA);
 
diff --git a/modules/desktop_capture/window_capturer_mac.mm b/modules/desktop_capture/window_capturer_mac.mm
index d7f85ccfcf978268b909081e2a76088ffe79c8e1..582cffd0440c96e6053c501d13e8e0bccf5ec86d 100644
--- a/modules/desktop_capture/window_capturer_mac.mm
+++ b/modules/desktop_capture/window_capturer_mac.mm
@@ -57,6 +57,7 @@ explicit WindowCapturerMac(
   // DesktopCapturer interface.
   void Start(Callback* callback) override;
   void CaptureFrame() override;
+  void SetMaskWindow(WindowId window) override; //+by xxlang@2022-10-14 : mask id
   bool GetSourceList(SourceList* sources) override;
   bool SelectSource(SourceId id) override;
   bool FocusOnSelectedSource() override;
@@ -68,6 +69,8 @@ explicit WindowCapturerMac(
   // The window being captured.
   CGWindowID window_id_ = 0;
 
+  CGWindowID mask_id_ = 0; //+by xxlang@2022-10-14 : mask id
+
   CGWindowID last_window_id_ = 0; //+by xxlang@2021-09-09
 
   rtc::scoped_refptr<FullScreenWindowDetector> full_screen_window_detector_;
@@ -101,6 +104,13 @@ explicit WindowCapturerMac(
 
 WindowCapturerMac::~WindowCapturerMac() {}
 
+//+by xxlang@2022-10-14 : mask id {
+void WindowCapturerMac::SetMaskWindow(WindowId window) {
+  RTC_LOG(LS_WARNING) << __func__;
+  mask_id_ = window;
+}
+//+by xxlang@2022-10-14 : mask id }
+
 bool WindowCapturerMac::GetSourceList(SourceList* sources) {
   return webrtc::GetWindowList(sources, true, true);
 }
@@ -166,6 +176,7 @@ explicit WindowCapturerMac(
 }
 
 void WindowCapturerMac::Start(Callback* callback) {
+  RTC_LOG(LS_WARNING) << __func__;
   assert(!callback_);
   assert(callback);
 
@@ -186,8 +197,11 @@ explicit WindowCapturerMac(
     if (first_capture_) {
       first_capture_ = false;
     } else {
-      RTC_LOG(LS_WARNING) << "WindowCapturerMac create border for window " << window_id_;
+      RTC_LOG(LS_WARNING) << "WindowCapturerMac create border for window " << window_id_ << " with mask " << mask_id_;
       window_border_->CreateForWindow(window_id_);
+      if (window_border_->IsCreated()) {
+        window_border_->SetMaskId(mask_id_);
+      }
     }
   }
   //+by xxlang@2021-10-21 }
@@ -221,7 +235,8 @@ explicit WindowCapturerMac(
     last_window_id_ = on_screen_window;
   }
 
-  std::unique_ptr<DesktopFrame> frame = DesktopFrameCGImage::CreateForWindow(on_screen_window);
+  std::unique_ptr<DesktopFrame> frame = DesktopFrameCGImage::CreateForWindowWithMask(on_screen_window, mask_id_); //+by xxlang@2022-09-30 : share annotation
+
   //+by xxlang@2022-03-28 : {
   // On macOS Mojave we receive a 1x1 frame when the shared window is off screen.
   // On macOS Catalina and Big Sur we receive null frame when the shared window is off screen.
