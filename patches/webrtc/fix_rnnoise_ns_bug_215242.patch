From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xiaoxia Lang <xxlang@grandstream.cn>
Date: Fri, 18 Feb 2022 08:30:22 +0800
Subject: fix_rnnoise_ns_bug_215242


diff --git a/modules/audio_processing/audio_buffer.cc b/modules/audio_processing/audio_buffer.cc
index ff6636df8790829c1b9ec0fee7a52f2bda0a4677..d6269fa921fd7ba9dd35d7e81d1fef29b099b5b3 100644
--- a/modules/audio_processing/audio_buffer.cc
+++ b/modules/audio_processing/audio_buffer.cc
@@ -211,6 +211,28 @@ void AudioBuffer::CopyTo(AudioBuffer* buffer) const {
   }
 }
 
+//+by xxlang@2022-02-17 {
+void AudioBuffer::CopyDataTo(AudioBuffer* buffer, bool use_split_band_data) const {
+  RTC_DCHECK_EQ(buffer->num_channels(), num_channels());
+  RTC_DCHECK_EQ(buffer->num_frames(), num_frames());
+  RTC_DCHECK_EQ(buffer->num_frames_per_band(), num_frames_per_band());
+  RTC_DCHECK_EQ(buffer->num_bands(), num_bands());
+
+  for (size_t channel = 0; channel < num_channels(); ++channel) {
+    if (use_split_band_data) {
+      for (size_t band = 0; band < num_bands(); ++band) {
+        memcpy(buffer->split_bands(channel)[band],
+               split_bands_const(channel)[band],
+               num_frames_per_band() * sizeof(**split_bands_const(channel)));
+      }
+    } else {
+      memcpy(buffer->channels()[channel], channels_const()[channel],
+             num_frames() * sizeof(**channels_const()));
+    }
+  }
+}
+//+by xxlang@2022-02-17 }
+
 void AudioBuffer::RestoreNumChannels() {
   num_channels_ = buffer_num_channels_;
   data_->set_num_channels(buffer_num_channels_);
diff --git a/modules/audio_processing/audio_buffer.h b/modules/audio_processing/audio_buffer.h
index 3eecf0dbaa55a20a397c0c39a42952e6ea282265..ab9e591b9eea85a25b84fcc411c0acc426a15308 100644
--- a/modules/audio_processing/audio_buffer.h
+++ b/modules/audio_processing/audio_buffer.h
@@ -118,6 +118,7 @@ class AudioBuffer {
               int16_t* const interleaved_data);
   void CopyTo(const StreamConfig& stream_config, float* const* stacked_data);
   void CopyTo(AudioBuffer* buffer) const;
+  void CopyDataTo(AudioBuffer* buffer, bool use_split_band_data) const; //+by xxlang@2022-02-17
 
   // Splits the buffer data into frequency bands.
   void SplitIntoFrequencyBands();
diff --git a/modules/audio_processing/audio_processing_impl.cc b/modules/audio_processing/audio_processing_impl.cc
index d2510b03dfe3d61a89a81642710102b4625a9972..f539d9056dcc63d752cfe4fda70ff8703da00e05 100644
--- a/modules/audio_processing/audio_processing_impl.cc
+++ b/modules/audio_processing/audio_processing_impl.cc
@@ -403,6 +403,16 @@ void AudioProcessingImpl::InitializeLocked() {
       formats_.api_format.output_stream().sample_rate_hz(),
       formats_.api_format.output_stream().num_channels()));
 
+  //+by xxlang@2022-02-17 {
+  capture_.capture_audio_rnnoise.reset(new AudioBuffer(
+      formats_.api_format.input_stream().sample_rate_hz(),
+      formats_.api_format.input_stream().num_channels(),
+      capture_nonlocked_.capture_processing_format.sample_rate_hz(),
+      formats_.api_format.output_stream().num_channels(),
+      formats_.api_format.output_stream().sample_rate_hz(),
+      formats_.api_format.output_stream().num_channels()));
+  //+by xxlang@2022-02-17 }
+
   if (capture_nonlocked_.capture_processing_format.sample_rate_hz() <
           formats_.api_format.output_stream().sample_rate_hz() &&
       formats_.api_format.output_stream().sample_rate_hz() == 48000) {
@@ -1226,7 +1236,6 @@ int AudioProcessingImpl::ProcessCaptureStreamLocked() {
         submodules_.gain_control->AnalyzeCaptureAudio(*capture_buffer));
   }
 
-  bool bands_merged = false; //+by xxlang@2021-07-28
   if ((!config_.noise_suppression.analyze_linear_aec_output_when_available ||
        !linear_aec_buffer || submodules_.echo_control_mobile) &&
       submodules_.noise_suppressor) {
@@ -1241,7 +1250,7 @@ int AudioProcessingImpl::ProcessCaptureStreamLocked() {
     }
 
     if (submodules_.noise_suppressor) {
-      bands_merged = submodules_.noise_suppressor->Process(capture_buffer);
+      ProcessNoiseSuppressorLocked(capture_buffer); //*by xxlang@2022-02-17
     }
 
     RETURN_ON_ERR(submodules_.echo_control_mobile->ProcessCaptureAudio(
@@ -1264,7 +1273,7 @@ int AudioProcessingImpl::ProcessCaptureStreamLocked() {
     }
 
     if (submodules_.noise_suppressor) {
-      bands_merged = submodules_.noise_suppressor->Process(capture_buffer);
+      ProcessNoiseSuppressorLocked(capture_buffer); //*by xxlang@2022-02-17
     }
   }
 
@@ -1291,7 +1300,7 @@ int AudioProcessingImpl::ProcessCaptureStreamLocked() {
         capture_buffer, /*stream_has_echo*/ false));
   }
 
-  if (!bands_merged && submodule_states_.CaptureMultiBandProcessingPresent() &&
+  if (submodule_states_.CaptureMultiBandProcessingPresent() &&
       SampleRateSupportsMultiBand(
           capture_nonlocked_.capture_processing_format.sample_rate_hz())) {
     capture_buffer->MergeFrequencyBands();
@@ -1432,6 +1441,27 @@ int AudioProcessingImpl::ProcessCaptureStreamLocked() {
   return kNoError;
 }
 
+//+by xxlang@2022-02-17 {
+void AudioProcessingImpl::ProcessNoiseSuppressorLocked(AudioBuffer* audio) {
+  RTC_DCHECK(submodules_.noise_suppressor);
+  RTC_DCHECK(audio);
+  AudioBuffer* audio_rnnoise = capture_.capture_audio_rnnoise.get();
+  RTC_DCHECK(audio_rnnoise);
+  RTC_LOG(LS_INFO) << "capture_buffer: noise_suppressor";
+  if (submodules_.noise_suppressor->RnnoiseAppliable(*audio) &&
+      submodules_.noise_suppressor->RnnoiseAppliable(*audio_rnnoise)) {
+    audio_rnnoise->set_num_channels(audio->num_channels());
+    audio->CopyDataTo(audio_rnnoise, true);
+    audio_rnnoise->MergeFrequencyBands(); // apply aec result to full band data
+    submodules_.noise_suppressor->Process(audio_rnnoise);
+    audio_rnnoise->SplitIntoFrequencyBands(); // apply ans result to split band data
+    audio_rnnoise->CopyDataTo(audio, true);
+  } else {
+    submodules_.noise_suppressor->Process(audio);
+  }
+}
+//+by xxlang@2022-02-17 }
+
 int AudioProcessingImpl::AnalyzeReverseStream(
     const float* const* data,
     const StreamConfig& reverse_config) {
diff --git a/modules/audio_processing/audio_processing_impl.h b/modules/audio_processing/audio_processing_impl.h
index e08abd5797b19a5a77e200d2710e9c7c84501763..1a98c0e0f70fe312220b128ae845cb5a3a0c8766 100644
--- a/modules/audio_processing/audio_processing_impl.h
+++ b/modules/audio_processing/audio_processing_impl.h
@@ -304,6 +304,8 @@ class AudioProcessingImpl : public AudioProcessing {
   // manner that are called with the render lock already acquired.
   int ProcessCaptureStreamLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_);
 
+  void ProcessNoiseSuppressorLocked(AudioBuffer* audio) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_capture_); //+by xxlang@2022-02-17
+
   // Render-side exclusive methods possibly running APM in a multi-threaded
   // manner that are called with the render lock already acquired.
   // TODO(ekm): Remove once all clients updated to new interface.
@@ -442,6 +444,7 @@ class AudioProcessingImpl : public AudioProcessing {
     bool capture_output_used_last_frame;
     bool key_pressed;
     std::unique_ptr<AudioBuffer> capture_audio;
+    std::unique_ptr<AudioBuffer> capture_audio_rnnoise; //+by xxlang@2022-02-17
     std::unique_ptr<AudioBuffer> capture_fullband_audio;
     std::unique_ptr<AudioBuffer> linear_aec_output;
     // Only the rate and samples fields of capture_processing_format_ are used
diff --git a/modules/audio_processing/ns/noise_suppressor.cc b/modules/audio_processing/ns/noise_suppressor.cc
index dea7c5280499699d7187d9bf1318f4a3cb1c0eb0..24ff990d17a00880cfbb52b66d93ee47b14364d7 100644
--- a/modules/audio_processing/ns/noise_suppressor.cc
+++ b/modules/audio_processing/ns/noise_suppressor.cc
@@ -266,7 +266,7 @@ NoiseSuppressor::NoiseSuppressor(const NsConfig& config,
       energies_before_filtering_heap_(NumChannelsOnHeap(num_channels_)),
       gain_adjustments_heap_(NumChannelsOnHeap(num_channels_)),
       channels_(num_channels_) {
-  RTC_LOG(LS_INFO) << "NoiseSuppressor: sample_rate_hz=" << sample_rate_hz << ", num_bands=" << num_bands_ << ", num_channels=" << num_channels_ << ", rnn_enabled=" << rnn_enabled_;
+  RTC_LOG(LS_WARNING) << "NoiseSuppressor: sample_rate_hz=" << sample_rate_hz << ", num_bands=" << num_bands_ << ", num_channels=" << num_channels_ << ", rnn_enabled=" << rnn_enabled_;
   for (size_t ch = 0; ch < num_channels_; ++ch) {
     channels_[ch] =
         std::make_unique<ChannelState>(suppression_params_, num_bands_);
@@ -291,7 +291,7 @@ void NoiseSuppressor::AggregateWienerFilters(
 
 void NoiseSuppressor::Analyze(const AudioBuffer& audio) {
   //+by xxlang@2021-07-20 {
-  if (rnn_enabled_ && audio.num_bands() == 3 && audio.num_frames() == 480) {
+  if (RnnoiseAppliable(audio)) {
     return;
   }
   //+by xxlang@2021-07-20 }
@@ -389,9 +389,13 @@ void NoiseSuppressor::Analyze(const AudioBuffer& audio) {
   }
 }
 
-bool NoiseSuppressor::Process(AudioBuffer* audio) {
+void NoiseSuppressor::Process(AudioBuffer* audio) {
   //+by xxlang@2021-07-20 {
-  if (rnn_enabled_ && audio->num_bands() == 3 && audio->num_frames() == 480) {
+  if (RnnoiseAppliable(*audio)) {
+    if (!capture_output_used_) {
+      return;
+    }
+
     if (!rnn_applyed_) {
       RTC_LOG(LS_WARNING) << "switch on rnnoise for noise_suppressor=" << this;
       rnn_applyed_ = true;
@@ -399,7 +403,7 @@ bool NoiseSuppressor::Process(AudioBuffer* audio) {
     for (size_t ch = 0; ch < audio->num_channels(); ++ch) {
       channels_[ch]->rnn_ns_.Process(audio->channels()[ch], audio->channels_const()[ch]);
     }
-    return true;
+    return;
   }
   if (rnn_applyed_) {
     RTC_LOG(LS_WARNING) << "switch off rnnoise for noise_suppressor=" << this;
@@ -478,7 +482,7 @@ bool NoiseSuppressor::Process(AudioBuffer* audio) {
   // Only do the below processing if the output of the audio processing module
   // is used.
   if (!capture_output_used_) {
-    return false;
+    return;
   }
 
   // Aggregate the Wiener filters for all channels.
@@ -577,8 +581,12 @@ bool NoiseSuppressor::Process(AudioBuffer* audio) {
       }
     }
   }
+}
 
-  return false;
+//+by xxlang@2022-02-17 {
+bool NoiseSuppressor::RnnoiseAppliable(const AudioBuffer& audio) {
+  return (rnn_enabled_ && audio.num_bands() == 3 && audio.num_frames() == 480);
 }
+//+by xxlang@2022-02-17 }
 
 }  // namespace webrtc
diff --git a/modules/audio_processing/ns/noise_suppressor.h b/modules/audio_processing/ns/noise_suppressor.h
index 78a4f1f3854186f9b632359aac8492c3a9574c51..11021bc92d7a00b617580f3377b82de0cd886058 100644
--- a/modules/audio_processing/ns/noise_suppressor.h
+++ b/modules/audio_processing/ns/noise_suppressor.h
@@ -41,7 +41,9 @@ class NoiseSuppressor {
   void Analyze(const AudioBuffer& audio);
 
   // Applies noise suppression.
-  bool Process(AudioBuffer* audio);
+  void Process(AudioBuffer* audio);
+
+  bool RnnoiseAppliable(const AudioBuffer& audio);  //+by xxlang@2022-02-17
 
   // Specifies whether the capture output will be used. The purpose of this is
   // to allow the noise suppressor to deactivate some of the processing when the
@@ -64,7 +66,7 @@ class NoiseSuppressor {
   struct ChannelState {
     ChannelState(const SuppressionParams& suppression_params, size_t num_bands);
 
-   	rnn_ns::RnnNs rnn_ns_; //+by xxlang@2021-07-20
+    rnn_ns::RnnNs rnn_ns_; //+by xxlang@2021-07-20
     SpeechProbabilityEstimator speech_probability_estimator;
     WienerFilter wiener_filter;
     NoiseEstimator noise_estimator;
diff --git a/modules/audio_processing/ns/rnn_ns/rnn.cc b/modules/audio_processing/ns/rnn_ns/rnn.cc
index c425e03a1476b3fb12cc9d92f7d68cadcddf59b6..4dc69c599eabcccb105fc812f2053aafd0966a70 100644
--- a/modules/audio_processing/ns/rnn_ns/rnn.cc
+++ b/modules/audio_processing/ns/rnn_ns/rnn.cc
@@ -16,18 +16,18 @@ namespace webrtc {
 namespace rnn_ns {
 
 RnnNs::RnnNs() {
-	st_ = rnnoise_create(NULL);
+  st_ = rnnoise_create(NULL);
 }
 
 RnnNs::~RnnNs() {
-	rnnoise_destroy(st_);
+  rnnoise_destroy(st_);
 }
 
 void RnnNs::Process(float* out, const float* in) {
-	rnnoise_process_frame(st_, out, in);
-	for (size_t i = 0; i < 480; i++) {
-		out[i] = std::min(std::max(out[i], -32768.f), 32767.f);
-	}
+  rnnoise_process_frame(st_, out, in);
+  for (size_t i = 0; i < 480; i++) {
+    out[i] = std::min(std::max(out[i], -32768.f), 32767.f);
+  }
 }
 
 } // namespace rnn_ns
diff --git a/modules/audio_processing/ns/rnn_ns/rnn.h b/modules/audio_processing/ns/rnn_ns/rnn.h
index 8c5a9feee1b3e0fb5b8d7edb782995265fc43eaa..1a5ed04b8236674d7aa80ab1f46a982a7e6bf0f3 100644
--- a/modules/audio_processing/ns/rnn_ns/rnn.h
+++ b/modules/audio_processing/ns/rnn_ns/rnn.h
@@ -22,15 +22,15 @@ namespace rnn_ns {
 // Recurrent network for noise supression.
 class RnnNs {
 public:
-	explicit RnnNs();
-	RnnNs(const RnnNs&) = delete;
-	RnnNs& operator=(const RnnNs&) = delete;
-	~RnnNs();
+  explicit RnnNs();
+  RnnNs(const RnnNs&) = delete;
+  RnnNs& operator=(const RnnNs&) = delete;
+  ~RnnNs();
 
-	void Process(float* out, const float* in);
+  void Process(float* out, const float* in);
 
 private:
-	struct DenoiseState* st_;
+  struct DenoiseState* st_;
 };
 
 } // namespace rnn_ns
